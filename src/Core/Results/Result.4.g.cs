// <auto-generated>
//     This code was generated by UnambitiousFx.Core.CodeGen.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

#nullable enable

using System;
using System.Diagnostics.CodeAnalysis;
using UnambitiousFx.Core.Results.Reasons;

namespace UnambitiousFx.Core.Results;

public partial class Result
{
    public static Result<TValue1, TValue2, TValue3, TValue4> Success<TValue1, TValue2, TValue3, TValue4>(TValue1 value1, TValue2 value2, TValue3 value3, TValue4 value4) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull {
        return new SuccessResult<TValue1, TValue2, TValue3, TValue4>(value1, value2, value3, value4);
    }
    
    public static Result<TValue1, TValue2, TValue3, TValue4> Failure<TValue1, TValue2, TValue3, TValue4>(Exception error) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull {
        return new FailureResult<TValue1, TValue2, TValue3, TValue4>(error);
    }
    
    public static Result<TValue1, TValue2, TValue3, TValue4> Failure<TValue1, TValue2, TValue3, TValue4>(IError error) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull {
        var r = new FailureResult<TValue1, TValue2, TValue3, TValue4>(error.Exception ?? new Exception(error.Message), false);
        r.AddReason(error);
        foreach (var kv in error.Metadata) {
            r.AddMetadata(kv.Key, kv.Value);
        }
        return r;
    }
    
    public static Result<TValue1, TValue2, TValue3, TValue4> Failure<TValue1, TValue2, TValue3, TValue4>(string message) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull {
        return new FailureResult<TValue1, TValue2, TValue3, TValue4>(new Exception(message));
    }
    
    public static Result<TValue1, TValue2, TValue3, TValue4> Failure<TValue1, TValue2, TValue3, TValue4>(IEnumerable<IError> errors) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull {
        return new FailureResult<TValue1, TValue2, TValue3, TValue4>(errors);
    }
    
}
/// <summary>
/// Represents the result of an operation that can succeed with 4 value(s) or fail with an exception.
/// </summary>
/// <typeparam name="TValue1">The type of the first value.</typeparam>
/// <typeparam name="TValue2">The type of the second value.</typeparam>
/// <typeparam name="TValue3">The type of the third value.</typeparam>
/// <typeparam name="TValue4">The type of the fourth value.</typeparam>
public abstract class Result<TValue1, TValue2, TValue3, TValue4> : BaseResult
    where TValue1 : notnull
    where TValue2 : notnull
    where TValue3 : notnull
    where TValue4 : notnull
{
    /// <summary>
    /// Pattern matches the result, executing the appropriate action.
    /// </summary>
    /// <param name="success">Action to execute if the result is successful</param>
    /// <param name="failure">Action to execute if the result is a failure</param>
    public abstract void Match(Action<TValue1, TValue2, TValue3, TValue4> success, Action<IEnumerable<IError>> failure);
    
    /// <summary>
    /// Pattern matches the result, returning a value from the appropriate function.
    /// </summary>
    /// <typeparam name="TOut">The type of value to return</typeparam>
    /// <param name="success">Function to invoke if the result is successful</param>
    /// <param name="failure">Function to invoke if the result is a failure</param>
    /// <returns>The result of invoking the appropriate function</returns>
    public abstract TOut Match<TOut>(Func<TValue1, TValue2, TValue3, TValue4, TOut> success, Func<IEnumerable<IError>, TOut> failure);
    
    /// <summary>
    /// Executes the action if the result is successful.
    /// </summary>
    /// <param name="action">Action to execute with the success values</param>
    public abstract void IfSuccess(Action<TValue1, TValue2, TValue3, TValue4> action);
    
    /// <summary>
    /// Attempts to extract the success values and error.
    /// </summary>
    /// <param name="value1">The first value if successful</param>
    /// <param name="value2">The second value if successful</param>
    /// <param name="value3">The third value if successful</param>
    /// <param name="value4">The fourth value if successful</param>
    /// <param name="error">The exception if failed</param>
    /// <returns>True if successful, false otherwise</returns>
    public abstract bool TryGet([NotNullWhen(true)] out TValue1? value1, [NotNullWhen(true)] out TValue2? value2, [NotNullWhen(true)] out TValue3? value3, [NotNullWhen(true)] out TValue4? value4, [NotNullWhen(false)] out IEnumerable<IError>? error);
    
    /// <summary>
    /// Attempts to extract the success values.
    /// </summary>
    /// <param name="value1">The first value if successful</param>
    /// <param name="value2">The second value if successful</param>
    /// <param name="value3">The third value if successful</param>
    /// <param name="value4">The fourth value if successful</param>
    /// <returns>True if successful, false otherwise</returns>
    public abstract bool TryGet([NotNullWhen(true)] out TValue1? value1, [NotNullWhen(true)] out TValue2? value2, [NotNullWhen(true)] out TValue3? value3, [NotNullWhen(true)] out TValue4? value4);
    
    /// <summary>
    /// Deconstructs the result into its components.
    /// </summary>
    /// <param name="value1">The success value(s) if successful</param>
    /// <param name="value2">The success value(s) if successful</param>
    /// <param name="value3">The success value(s) if successful</param>
    /// <param name="value4">The success value(s) if successful</param>
    /// <param name="error">The exception if failed</param>
    public abstract void Deconstruct(out TValue1? value1, out TValue2? value2, out TValue3? value3, out TValue4? value4, out IEnumerable<IError>? error);
    
}
