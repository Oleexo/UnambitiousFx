// <auto-generated>
//     This code was generated by UnambitiousFx.Core.CodeGen.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

#nullable enable

using System;
using System.Diagnostics.CodeAnalysis;
using UnambitiousFx.Core.Results.Reasons;

namespace UnambitiousFx.Core.Results;

public partial class Result
{
    public static Result<TValue1, TValue2> Success<TValue1, TValue2>(TValue1 value1, TValue2 value2) where TValue1 : notnull where TValue2 : notnull {
        return new SuccessResult<TValue1, TValue2>(value1, value2);
    }
    
    public static Result<TValue1, TValue2> Failure<TValue1, TValue2>(Exception error) where TValue1 : notnull where TValue2 : notnull {
        return new FailureResult<TValue1, TValue2>(error);
    }
    
    public static Result<TValue1, TValue2> Failure<TValue1, TValue2>(IError error) where TValue1 : notnull where TValue2 : notnull {
        var r = new FailureResult<TValue1, TValue2>(error.Exception ?? new Exception(error.Message), false);
        r.AddReason(error);
        foreach (var kv in error.Metadata) {
            r.AddMetadata(kv.Key, kv.Value);
        }
        return r;
    }
    
    public static Result<TValue1, TValue2> Failure<TValue1, TValue2>(string message) where TValue1 : notnull where TValue2 : notnull {
        return new FailureResult<TValue1, TValue2>(new Exception(message));
    }
    
    public static Result<TValue1, TValue2> Failure<TValue1, TValue2>(IEnumerable<IError> errors) where TValue1 : notnull where TValue2 : notnull {
        return new FailureResult<TValue1, TValue2>(errors);
    }
    
}
/// <summary>
/// Represents the result of an operation that can succeed with 2 value(s) or fail with an exception.
/// </summary>
/// <typeparam name="TValue1">The type of the first value.</typeparam>
/// <typeparam name="TValue2">The type of the second value.</typeparam>
public abstract class Result<TValue1, TValue2> : BaseResult
    where TValue1 : notnull
    where TValue2 : notnull
{
    /// <summary>
    /// Pattern matches the result, executing the appropriate action.
    /// </summary>
    /// <param name="success">Action to execute if the result is successful</param>
    /// <param name="failure">Action to execute if the result is a failure</param>
    public abstract void Match(Action<TValue1, TValue2> success, Action<IEnumerable<IError>> failure);
    
    /// <summary>
    /// Pattern matches the result, returning a value from the appropriate function.
    /// </summary>
    /// <typeparam name="TOut">The type of value to return</typeparam>
    /// <param name="success">Function to invoke if the result is successful</param>
    /// <param name="failure">Function to invoke if the result is a failure</param>
    /// <returns>The result of invoking the appropriate function</returns>
    public abstract TOut Match<TOut>(Func<TValue1, TValue2, TOut> success, Func<IEnumerable<IError>, TOut> failure);
    
    /// <summary>
    /// Executes the action if the result is successful.
    /// </summary>
    /// <param name="action">Action to execute with the success values</param>
    public abstract void IfSuccess(Action<TValue1, TValue2> action);
    
    /// <summary>
    /// Attempts to extract the success values and error.
    /// </summary>
    /// <param name="value1">The first value if successful</param>
    /// <param name="value2">The second value if successful</param>
    /// <param name="error">The exception if failed</param>
    /// <returns>True if successful, false otherwise</returns>
    public abstract bool TryGet([NotNullWhen(true)] out TValue1? value1, [NotNullWhen(true)] out TValue2? value2, [NotNullWhen(false)] out IEnumerable<IError>? error);
    
    /// <summary>
    /// Attempts to extract the success values.
    /// </summary>
    /// <param name="value1">The first value if successful</param>
    /// <param name="value2">The second value if successful</param>
    /// <returns>True if successful, false otherwise</returns>
    public abstract bool TryGet([NotNullWhen(true)] out TValue1? value1, [NotNullWhen(true)] out TValue2? value2);
    
    /// <summary>
    /// Deconstructs the result into its components.
    /// </summary>
    /// <param name="isSuccess">Whether the result is successful</param>
    /// <param name="value">The success value(s) if successful</param>
    /// <param name="error">The exception if failed</param>
    public abstract void Deconstruct(out bool isSuccess, out (TValue1, TValue2)? value, out IEnumerable<IError>? error);
    
}
