// <auto-generated>
//     This code was generated by UnambitiousFx.Core.CodeGen.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

#nullable enable

using UnambitiousFx.Core.Results.Reasons;

namespace UnambitiousFx.Core.Results.Extensions.ErrorHandling;

public static partial class ResultFilterErrorExtensions
{
    #region Arity 0
    
    /// <summary>
    /// Core method for filtering errors from a result based on a predicate.
    /// </summary>
    /// <typeparam name="TRes">The result type to return.</typeparam>
    /// <param name="original">The original result to filter.</param>
    /// <param name="predicate">The predicate to determine which errors to keep.</param>
    /// <param name="successFactory">Factory function to create success results.</param>
    /// <param name="failureFactory">Factory function to create failure results.</param>
    /// <returns>A result with only the errors that match the predicate.</returns>
    private static TRes FilterErrorCore<TRes>(BaseResult original, Func<IError, bool> predicate, Func<TRes> successFactory, Func<IError, TRes> failureFactory) where TRes : BaseResult {
        ArgumentNullException.ThrowIfNull(predicate);
        if (original.IsSuccess)
        {
            return (TRes)original;
        }
        var successes = original.Reasons.Where(r => r is not IError)
                              .ToList();
        var errorsKept = original.Reasons.OfType<IError>()
                               .Where(predicate)
                               .Cast<IReason>()
                               .ToList();
        if (errorsKept.Count == 0)
        {
            var success = successFactory();
            if (successes.Count != 0)
            {
                success.WithReasons(successes);
            }
            if (original.Metadata.Count != 0)
            {
                success.WithMetadata(original.Metadata);
            }
            return success;
        }
        var firstErr = (IError)errorsKept[0];
        var failure  = failureFactory(firstErr);
        foreach (var reason in errorsKept.Skip(1))
        {
            failure.WithReason(reason);
        }
        if (successes.Count != 0)
        {
            failure.WithReasons(successes);
        }
        if (original.Metadata.Count != 0)
        {
            failure.WithMetadata(original.Metadata);
        }
        return failure;
    }
    
    /// <summary>
    /// Filters errors from the result based on the specified predicate.
    /// </summary>
    /// <param name="result">The result to filter errors from.</param>
    /// <param name="predicate">The predicate to determine which errors to keep.</param>
    /// <returns>A result with only the errors that match the predicate. If no errors match, returns a success result.</returns>
    public static Result FilterError(this Result result, Func<IError, bool> predicate) {
        return FilterErrorCore(result,
                               predicate,
                               Result.Success,
                               Result.Failure);
    }
    
    #endregion // Arity 0
    
    #region Arity 1
    
    /// <summary>
    /// Filters errors from the result based on the specified predicate.
    /// </summary>
    /// <typeparam name="TValue1">The type of the first value.</typeparam>
    /// <param name="result">The result to filter errors from.</param>
    /// <param name="predicate">The predicate to determine which errors to keep.</param>
    /// <returns>A result with only the errors that match the predicate. If no errors match, returns a success result.</returns>
    public static Result<TValue1> FilterError<TValue1>(this Result<TValue1> result, Func<IError, bool> predicate) where TValue1 : notnull {
        return FilterErrorCore(result,
                               predicate,
                               () => Result.Success(default(TValue1)!),
                               Result.Failure<TValue1>);
    }
    
    #endregion // Arity 1
    
    #region Arity 2
    
    /// <summary>
    /// Filters errors from the result based on the specified predicate.
    /// </summary>
    /// <typeparam name="TValue1">The type of the first value.</typeparam>
    /// <typeparam name="TValue2">The type of the second value.</typeparam>
    /// <param name="result">The result to filter errors from.</param>
    /// <param name="predicate">The predicate to determine which errors to keep.</param>
    /// <returns>A result with only the errors that match the predicate. If no errors match, returns a success result.</returns>
    public static Result<TValue1, TValue2> FilterError<TValue1, TValue2>(this Result<TValue1, TValue2> result, Func<IError, bool> predicate) where TValue1 : notnull where TValue2 : notnull {
        return FilterErrorCore(result,
                               predicate,
                               () => Result.Success(default(TValue1)!, default(TValue2)!),
                               Result.Failure<TValue1, TValue2>);
    }
    
    #endregion // Arity 2
    
    #region Arity 3
    
    /// <summary>
    /// Filters errors from the result based on the specified predicate.
    /// </summary>
    /// <typeparam name="TValue1">The type of the first value.</typeparam>
    /// <typeparam name="TValue2">The type of the second value.</typeparam>
    /// <typeparam name="TValue3">The type of the third value.</typeparam>
    /// <param name="result">The result to filter errors from.</param>
    /// <param name="predicate">The predicate to determine which errors to keep.</param>
    /// <returns>A result with only the errors that match the predicate. If no errors match, returns a success result.</returns>
    public static Result<TValue1, TValue2, TValue3> FilterError<TValue1, TValue2, TValue3>(this Result<TValue1, TValue2, TValue3> result, Func<IError, bool> predicate) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull {
        return FilterErrorCore(result,
                               predicate,
                               () => Result.Success(default(TValue1)!, default(TValue2)!, default(TValue3)!),
                               Result.Failure<TValue1, TValue2, TValue3>);
    }
    
    #endregion // Arity 3
    
    #region Arity 4
    
    /// <summary>
    /// Filters errors from the result based on the specified predicate.
    /// </summary>
    /// <typeparam name="TValue1">The type of the first value.</typeparam>
    /// <typeparam name="TValue2">The type of the second value.</typeparam>
    /// <typeparam name="TValue3">The type of the third value.</typeparam>
    /// <typeparam name="TValue4">The type of the fourth value.</typeparam>
    /// <param name="result">The result to filter errors from.</param>
    /// <param name="predicate">The predicate to determine which errors to keep.</param>
    /// <returns>A result with only the errors that match the predicate. If no errors match, returns a success result.</returns>
    public static Result<TValue1, TValue2, TValue3, TValue4> FilterError<TValue1, TValue2, TValue3, TValue4>(this Result<TValue1, TValue2, TValue3, TValue4> result, Func<IError, bool> predicate) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull {
        return FilterErrorCore(result,
                               predicate,
                               () => Result.Success(default(TValue1)!, default(TValue2)!, default(TValue3)!, default(TValue4)!),
                               Result.Failure<TValue1, TValue2, TValue3, TValue4>);
    }
    
    #endregion // Arity 4
    
    #region Arity 5
    
    /// <summary>
    /// Filters errors from the result based on the specified predicate.
    /// </summary>
    /// <typeparam name="TValue1">The type of the first value.</typeparam>
    /// <typeparam name="TValue2">The type of the second value.</typeparam>
    /// <typeparam name="TValue3">The type of the third value.</typeparam>
    /// <typeparam name="TValue4">The type of the fourth value.</typeparam>
    /// <typeparam name="TValue5">The type of the fifth value.</typeparam>
    /// <param name="result">The result to filter errors from.</param>
    /// <param name="predicate">The predicate to determine which errors to keep.</param>
    /// <returns>A result with only the errors that match the predicate. If no errors match, returns a success result.</returns>
    public static Result<TValue1, TValue2, TValue3, TValue4, TValue5> FilterError<TValue1, TValue2, TValue3, TValue4, TValue5>(this Result<TValue1, TValue2, TValue3, TValue4, TValue5> result, Func<IError, bool> predicate) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull where TValue5 : notnull {
        return FilterErrorCore(result,
                               predicate,
                               () => Result.Success(default(TValue1)!, default(TValue2)!, default(TValue3)!, default(TValue4)!, default(TValue5)!),
                               Result.Failure<TValue1, TValue2, TValue3, TValue4, TValue5>);
    }
    
    #endregion // Arity 5
    
    #region Arity 6
    
    /// <summary>
    /// Filters errors from the result based on the specified predicate.
    /// </summary>
    /// <typeparam name="TValue1">The type of the first value.</typeparam>
    /// <typeparam name="TValue2">The type of the second value.</typeparam>
    /// <typeparam name="TValue3">The type of the third value.</typeparam>
    /// <typeparam name="TValue4">The type of the fourth value.</typeparam>
    /// <typeparam name="TValue5">The type of the fifth value.</typeparam>
    /// <typeparam name="TValue6">The type of the sixth value.</typeparam>
    /// <param name="result">The result to filter errors from.</param>
    /// <param name="predicate">The predicate to determine which errors to keep.</param>
    /// <returns>A result with only the errors that match the predicate. If no errors match, returns a success result.</returns>
    public static Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6> FilterError<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(this Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6> result, Func<IError, bool> predicate) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull where TValue5 : notnull where TValue6 : notnull {
        return FilterErrorCore(result,
                               predicate,
                               () => Result.Success(default(TValue1)!, default(TValue2)!, default(TValue3)!, default(TValue4)!, default(TValue5)!, default(TValue6)!),
                               Result.Failure<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>);
    }
    
    #endregion // Arity 6
    
    #region Arity 7
    
    /// <summary>
    /// Filters errors from the result based on the specified predicate.
    /// </summary>
    /// <typeparam name="TValue1">The type of the first value.</typeparam>
    /// <typeparam name="TValue2">The type of the second value.</typeparam>
    /// <typeparam name="TValue3">The type of the third value.</typeparam>
    /// <typeparam name="TValue4">The type of the fourth value.</typeparam>
    /// <typeparam name="TValue5">The type of the fifth value.</typeparam>
    /// <typeparam name="TValue6">The type of the sixth value.</typeparam>
    /// <typeparam name="TValue7">The type of the seventh value.</typeparam>
    /// <param name="result">The result to filter errors from.</param>
    /// <param name="predicate">The predicate to determine which errors to keep.</param>
    /// <returns>A result with only the errors that match the predicate. If no errors match, returns a success result.</returns>
    public static Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7> FilterError<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(this Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7> result, Func<IError, bool> predicate) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull where TValue5 : notnull where TValue6 : notnull where TValue7 : notnull {
        return FilterErrorCore(result,
                               predicate,
                               () => Result.Success(default(TValue1)!, default(TValue2)!, default(TValue3)!, default(TValue4)!, default(TValue5)!, default(TValue6)!, default(TValue7)!),
                               Result.Failure<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>);
    }
    
    #endregion // Arity 7
    
    #region Arity 8
    
    /// <summary>
    /// Filters errors from the result based on the specified predicate.
    /// </summary>
    /// <typeparam name="TValue1">The type of the first value.</typeparam>
    /// <typeparam name="TValue2">The type of the second value.</typeparam>
    /// <typeparam name="TValue3">The type of the third value.</typeparam>
    /// <typeparam name="TValue4">The type of the fourth value.</typeparam>
    /// <typeparam name="TValue5">The type of the fifth value.</typeparam>
    /// <typeparam name="TValue6">The type of the sixth value.</typeparam>
    /// <typeparam name="TValue7">The type of the seventh value.</typeparam>
    /// <typeparam name="TValue8">The type of the eighth value.</typeparam>
    /// <param name="result">The result to filter errors from.</param>
    /// <param name="predicate">The predicate to determine which errors to keep.</param>
    /// <returns>A result with only the errors that match the predicate. If no errors match, returns a success result.</returns>
    public static Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8> FilterError<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(this Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8> result, Func<IError, bool> predicate) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull where TValue5 : notnull where TValue6 : notnull where TValue7 : notnull where TValue8 : notnull {
        return FilterErrorCore(result,
                               predicate,
                               () => Result.Success(default(TValue1)!, default(TValue2)!, default(TValue3)!, default(TValue4)!, default(TValue5)!, default(TValue6)!, default(TValue7)!, default(TValue8)!),
                               Result.Failure<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>);
    }
    
    #endregion // Arity 8
}
