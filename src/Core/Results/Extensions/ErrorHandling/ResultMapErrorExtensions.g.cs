// <auto-generated>
//     This code was generated by UnambitiousFx.Core.CodeGen.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

#nullable enable

using UnambitiousFx.Core.Results.Reasons;
using UnambitiousFx.Core.Results.Types;

namespace UnambitiousFx.Core.Results.Extensions.ErrorHandling;

public static partial class ResultMapErrorExtensions
{
    #region Arity 0
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result MapError(this Result result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError) {
        return result.Match(
            Result.Success,
            ex => Result.Failure(mapError(ex))
        );
    }
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function and policy.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <param name="policy">The policy controlling how successive MapError operations behave.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result MapError(this Result result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError, MapErrorChainPolicy policy) {
        if (result.IsSuccess) {
            return result;
        }
        return policy switch {
            MapErrorChainPolicy.ShortCircuit => result.MapError(mapError),
            MapErrorChainPolicy.Accumulate   => result.Accumulate(mapError),
            _                                => throw new ArgumentOutOfRangeException(nameof(policy), policy, null)
        };
    }
    
    #endregion // Arity 0
    
    #region Arity 1
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<T1> MapError<T1>(this Result<T1> result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError) where T1 : notnull {
        return result.Match(
            Result.Success,
            ex => Result.Failure<T1>(mapError(ex))
        );
    }
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function and policy.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <param name="policy">The policy controlling how successive MapError operations behave.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<T1> MapError<T1>(this Result<T1> result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError, MapErrorChainPolicy policy) where T1 : notnull {
        if (result.IsSuccess) {
            return result;
        }
        return policy switch {
            MapErrorChainPolicy.ShortCircuit => result.MapError(mapError),
            MapErrorChainPolicy.Accumulate   => result.Accumulate(mapError),
            _                                => throw new ArgumentOutOfRangeException(nameof(policy), policy, null)
        };
    }
    
    #endregion // Arity 1
    
    #region Arity 2
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<T1, T2> MapError<T1, T2>(this Result<T1, T2> result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError) where T1 : notnull where T2 : notnull {
        return result.Match(
            Result.Success,
            ex => Result.Failure<T1, T2>(mapError(ex))
        );
    }
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function and policy.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <param name="policy">The policy controlling how successive MapError operations behave.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<T1, T2> MapError<T1, T2>(this Result<T1, T2> result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError, MapErrorChainPolicy policy) where T1 : notnull where T2 : notnull {
        if (result.IsSuccess) {
            return result;
        }
        return policy switch {
            MapErrorChainPolicy.ShortCircuit => result.MapError(mapError),
            MapErrorChainPolicy.Accumulate   => result.Accumulate(mapError),
            _                                => throw new ArgumentOutOfRangeException(nameof(policy), policy, null)
        };
    }
    
    #endregion // Arity 2
    
    #region Arity 3
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<T1, T2, T3> MapError<T1, T2, T3>(this Result<T1, T2, T3> result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull {
        return result.Match(
            Result.Success,
            ex => Result.Failure<T1, T2, T3>(mapError(ex))
        );
    }
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function and policy.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <param name="policy">The policy controlling how successive MapError operations behave.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<T1, T2, T3> MapError<T1, T2, T3>(this Result<T1, T2, T3> result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError, MapErrorChainPolicy policy) where T1 : notnull where T2 : notnull where T3 : notnull {
        if (result.IsSuccess) {
            return result;
        }
        return policy switch {
            MapErrorChainPolicy.ShortCircuit => result.MapError(mapError),
            MapErrorChainPolicy.Accumulate   => result.Accumulate(mapError),
            _                                => throw new ArgumentOutOfRangeException(nameof(policy), policy, null)
        };
    }
    
    #endregion // Arity 3
    
    #region Arity 4
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<T1, T2, T3, T4> MapError<T1, T2, T3, T4>(this Result<T1, T2, T3, T4> result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull {
        return result.Match(
            Result.Success,
            ex => Result.Failure<T1, T2, T3, T4>(mapError(ex))
        );
    }
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function and policy.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <param name="policy">The policy controlling how successive MapError operations behave.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<T1, T2, T3, T4> MapError<T1, T2, T3, T4>(this Result<T1, T2, T3, T4> result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError, MapErrorChainPolicy policy) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull {
        if (result.IsSuccess) {
            return result;
        }
        return policy switch {
            MapErrorChainPolicy.ShortCircuit => result.MapError(mapError),
            MapErrorChainPolicy.Accumulate   => result.Accumulate(mapError),
            _                                => throw new ArgumentOutOfRangeException(nameof(policy), policy, null)
        };
    }
    
    #endregion // Arity 4
    
    #region Arity 5
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<T1, T2, T3, T4, T5> MapError<T1, T2, T3, T4, T5>(this Result<T1, T2, T3, T4, T5> result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull {
        return result.Match(
            Result.Success,
            ex => Result.Failure<T1, T2, T3, T4, T5>(mapError(ex))
        );
    }
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function and policy.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <param name="policy">The policy controlling how successive MapError operations behave.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<T1, T2, T3, T4, T5> MapError<T1, T2, T3, T4, T5>(this Result<T1, T2, T3, T4, T5> result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError, MapErrorChainPolicy policy) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull {
        if (result.IsSuccess) {
            return result;
        }
        return policy switch {
            MapErrorChainPolicy.ShortCircuit => result.MapError(mapError),
            MapErrorChainPolicy.Accumulate   => result.Accumulate(mapError),
            _                                => throw new ArgumentOutOfRangeException(nameof(policy), policy, null)
        };
    }
    
    #endregion // Arity 5
    
    #region Arity 6
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<T1, T2, T3, T4, T5, T6> MapError<T1, T2, T3, T4, T5, T6>(this Result<T1, T2, T3, T4, T5, T6> result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull {
        return result.Match(
            Result.Success,
            ex => Result.Failure<T1, T2, T3, T4, T5, T6>(mapError(ex))
        );
    }
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function and policy.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <param name="policy">The policy controlling how successive MapError operations behave.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<T1, T2, T3, T4, T5, T6> MapError<T1, T2, T3, T4, T5, T6>(this Result<T1, T2, T3, T4, T5, T6> result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError, MapErrorChainPolicy policy) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull {
        if (result.IsSuccess) {
            return result;
        }
        return policy switch {
            MapErrorChainPolicy.ShortCircuit => result.MapError(mapError),
            MapErrorChainPolicy.Accumulate   => result.Accumulate(mapError),
            _                                => throw new ArgumentOutOfRangeException(nameof(policy), policy, null)
        };
    }
    
    #endregion // Arity 6
    
    #region Arity 7
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<T1, T2, T3, T4, T5, T6, T7> MapError<T1, T2, T3, T4, T5, T6, T7>(this Result<T1, T2, T3, T4, T5, T6, T7> result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull where T7 : notnull {
        return result.Match(
            Result.Success,
            ex => Result.Failure<T1, T2, T3, T4, T5, T6, T7>(mapError(ex))
        );
    }
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function and policy.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <param name="policy">The policy controlling how successive MapError operations behave.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<T1, T2, T3, T4, T5, T6, T7> MapError<T1, T2, T3, T4, T5, T6, T7>(this Result<T1, T2, T3, T4, T5, T6, T7> result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError, MapErrorChainPolicy policy) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull where T7 : notnull {
        if (result.IsSuccess) {
            return result;
        }
        return policy switch {
            MapErrorChainPolicy.ShortCircuit => result.MapError(mapError),
            MapErrorChainPolicy.Accumulate   => result.Accumulate(mapError),
            _                                => throw new ArgumentOutOfRangeException(nameof(policy), policy, null)
        };
    }
    
    #endregion // Arity 7
    
    #region Arity 8
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<T1, T2, T3, T4, T5, T6, T7, T8> MapError<T1, T2, T3, T4, T5, T6, T7, T8>(this Result<T1, T2, T3, T4, T5, T6, T7, T8> result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull where T7 : notnull where T8 : notnull {
        return result.Match(
            Result.Success,
            ex => Result.Failure<T1, T2, T3, T4, T5, T6, T7, T8>(mapError(ex))
        );
    }
    
    /// <summary>
    /// Maps errors in the result using the specified mapping function and policy.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The function to map errors.</param>
    /// <param name="policy">The policy controlling how successive MapError operations behave.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<T1, T2, T3, T4, T5, T6, T7, T8> MapError<T1, T2, T3, T4, T5, T6, T7, T8>(this Result<T1, T2, T3, T4, T5, T6, T7, T8> result, Func<IEnumerable<IError>, IEnumerable<IError>> mapError, MapErrorChainPolicy policy) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull where T7 : notnull where T8 : notnull {
        if (result.IsSuccess) {
            return result;
        }
        return policy switch {
            MapErrorChainPolicy.ShortCircuit => result.MapError(mapError),
            MapErrorChainPolicy.Accumulate   => result.Accumulate(mapError),
            _                                => throw new ArgumentOutOfRangeException(nameof(policy), policy, null)
        };
    }
    
    #endregion // Arity 8
}
