// <auto-generated>
//     This code was generated by UnambitiousFx.Core.CodeGen.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

#nullable enable

using UnambitiousFx.Core.Results.Extensions.ValueAccess.ValueTasks;
using UnambitiousFx.Core.Results.Reasons;

namespace UnambitiousFx.Core.Results.Extensions.ErrorHandling.ValueTasks;

public static partial class ResultExtensions
{
    #region Arity 0
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static ValueTask<Result> MapErrorAsync(this Result result, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) {
        return result.Match<ValueTask<Result>>(
                                () => new ValueTask<Result>(Result.Success()),
                                async ex => Result.Failure(await mapError(ex))
                            );
    }
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static async ValueTask<Result> MapErrorAsync(this ValueTask<Result> awaitableResult, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) {
        var result = await awaitableResult;
        return await result.MapErrorAsync(mapError);
    }
    
    #endregion // Arity 0
    
    #region Arity 1
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static ValueTask<Result<T1>> MapErrorAsync<T1>(this Result<T1> result, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull {
        return result.Match<ValueTask<Result<T1>>>(
                            value1 => new ValueTask<Result<T1>>(Result.Success(value1)),
                            async ex => Result.Failure<T1>(await mapError(ex))
                        );
    }
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static async ValueTask<Result<T1>> MapErrorAsync<T1>(this ValueTask<Result<T1>> awaitableResult, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull {
        var result = await awaitableResult;
        return await result.MapErrorAsync(mapError);
    }
    
    #endregion // Arity 1
    
    #region Arity 2
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static ValueTask<Result<T1, T2>> MapErrorAsync<T1, T2>(this Result<T1, T2> result, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull {
        return result.Match<ValueTask<Result<T1, T2>>>(
                            (value1,
                     value2) => new ValueTask<Result<T1, T2>>(Result.Success(value1, value2)),
                            async ex => Result.Failure<T1, T2>(await mapError(ex))
                        );
    }
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static async ValueTask<Result<T1, T2>> MapErrorAsync<T1, T2>(this ValueTask<Result<T1, T2>> awaitableResult, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull {
        var result = await awaitableResult;
        return await result.MapErrorAsync(mapError);
    }
    
    #endregion // Arity 2
    
    #region Arity 3
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static ValueTask<Result<T1, T2, T3>> MapErrorAsync<T1, T2, T3>(this Result<T1, T2, T3> result, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull {
        return result.Match<ValueTask<Result<T1, T2, T3>>>(
                            (value1,
                     value2,
                     value3) => new ValueTask<Result<T1, T2, T3>>(Result.Success(value1, value2, value3)),
                            async ex => Result.Failure<T1, T2, T3>(await mapError(ex))
                        );
    }
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static async ValueTask<Result<T1, T2, T3>> MapErrorAsync<T1, T2, T3>(this ValueTask<Result<T1, T2, T3>> awaitableResult, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull {
        var result = await awaitableResult;
        return await result.MapErrorAsync(mapError);
    }
    
    #endregion // Arity 3
    
    #region Arity 4
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static ValueTask<Result<T1, T2, T3, T4>> MapErrorAsync<T1, T2, T3, T4>(this Result<T1, T2, T3, T4> result, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull {
        return result.Match<ValueTask<Result<T1, T2, T3, T4>>>(
                            (value1,
                     value2,
                     value3,
                     value4) => new ValueTask<Result<T1, T2, T3, T4>>(Result.Success(value1, value2, value3, value4)),
                            async ex => Result.Failure<T1, T2, T3, T4>(await mapError(ex))
                        );
    }
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static async ValueTask<Result<T1, T2, T3, T4>> MapErrorAsync<T1, T2, T3, T4>(this ValueTask<Result<T1, T2, T3, T4>> awaitableResult, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull {
        var result = await awaitableResult;
        return await result.MapErrorAsync(mapError);
    }
    
    #endregion // Arity 4
    
    #region Arity 5
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <typeparam name="T5">The type of the fifth value.</typeparam>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static ValueTask<Result<T1, T2, T3, T4, T5>> MapErrorAsync<T1, T2, T3, T4, T5>(this Result<T1, T2, T3, T4, T5> result, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull {
        return result.Match<ValueTask<Result<T1, T2, T3, T4, T5>>>(
                            (value1,
                     value2,
                     value3,
                     value4,
                     value5) => new ValueTask<Result<T1, T2, T3, T4, T5>>(Result.Success(value1, value2, value3, value4, value5)),
                            async ex => Result.Failure<T1, T2, T3, T4, T5>(await mapError(ex))
                        );
    }
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <typeparam name="T5">The type of the fifth value.</typeparam>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static async ValueTask<Result<T1, T2, T3, T4, T5>> MapErrorAsync<T1, T2, T3, T4, T5>(this ValueTask<Result<T1, T2, T3, T4, T5>> awaitableResult, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull {
        var result = await awaitableResult;
        return await result.MapErrorAsync(mapError);
    }
    
    #endregion // Arity 5
    
    #region Arity 6
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <typeparam name="T5">The type of the fifth value.</typeparam>
    /// <typeparam name="T6">The type of the sixth value.</typeparam>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static ValueTask<Result<T1, T2, T3, T4, T5, T6>> MapErrorAsync<T1, T2, T3, T4, T5, T6>(this Result<T1, T2, T3, T4, T5, T6> result, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull {
        return result.Match<ValueTask<Result<T1, T2, T3, T4, T5, T6>>>(
                            (value1,
                     value2,
                     value3,
                     value4,
                     value5,
                     value6) => new ValueTask<Result<T1, T2, T3, T4, T5, T6>>(Result.Success(value1, value2, value3, value4, value5, value6)),
                            async ex => Result.Failure<T1, T2, T3, T4, T5, T6>(await mapError(ex))
                        );
    }
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <typeparam name="T5">The type of the fifth value.</typeparam>
    /// <typeparam name="T6">The type of the sixth value.</typeparam>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static async ValueTask<Result<T1, T2, T3, T4, T5, T6>> MapErrorAsync<T1, T2, T3, T4, T5, T6>(this ValueTask<Result<T1, T2, T3, T4, T5, T6>> awaitableResult, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull {
        var result = await awaitableResult;
        return await result.MapErrorAsync(mapError);
    }
    
    #endregion // Arity 6
    
    #region Arity 7
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <typeparam name="T5">The type of the fifth value.</typeparam>
    /// <typeparam name="T6">The type of the sixth value.</typeparam>
    /// <typeparam name="T7">The type of the seventh value.</typeparam>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static ValueTask<Result<T1, T2, T3, T4, T5, T6, T7>> MapErrorAsync<T1, T2, T3, T4, T5, T6, T7>(this Result<T1, T2, T3, T4, T5, T6, T7> result, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull where T7 : notnull {
        return result.Match<ValueTask<Result<T1, T2, T3, T4, T5, T6, T7>>>(
                            (value1,
                     value2,
                     value3,
                     value4,
                     value5,
                     value6,
                     value7) => new ValueTask<Result<T1, T2, T3, T4, T5, T6, T7>>(Result.Success(value1, value2, value3, value4, value5, value6, value7)),
                            async ex => Result.Failure<T1, T2, T3, T4, T5, T6, T7>(await mapError(ex))
                        );
    }
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <typeparam name="T5">The type of the fifth value.</typeparam>
    /// <typeparam name="T6">The type of the sixth value.</typeparam>
    /// <typeparam name="T7">The type of the seventh value.</typeparam>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static async ValueTask<Result<T1, T2, T3, T4, T5, T6, T7>> MapErrorAsync<T1, T2, T3, T4, T5, T6, T7>(this ValueTask<Result<T1, T2, T3, T4, T5, T6, T7>> awaitableResult, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull where T7 : notnull {
        var result = await awaitableResult;
        return await result.MapErrorAsync(mapError);
    }
    
    #endregion // Arity 7
    
    #region Arity 8
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <typeparam name="T5">The type of the fifth value.</typeparam>
    /// <typeparam name="T6">The type of the sixth value.</typeparam>
    /// <typeparam name="T7">The type of the seventh value.</typeparam>
    /// <typeparam name="T8">The type of the eighth value.</typeparam>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static ValueTask<Result<T1, T2, T3, T4, T5, T6, T7, T8>> MapErrorAsync<T1, T2, T3, T4, T5, T6, T7, T8>(this Result<T1, T2, T3, T4, T5, T6, T7, T8> result, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull where T7 : notnull where T8 : notnull {
        return result.Match<ValueTask<Result<T1, T2, T3, T4, T5, T6, T7, T8>>>(
                            (value1,
                     value2,
                     value3,
                     value4,
                     value5,
                     value6,
                     value7,
                     value8) => new ValueTask<Result<T1, T2, T3, T4, T5, T6, T7, T8>>(Result.Success(value1, value2, value3, value4, value5, value6, value7, value8)),
                            async ex => Result.Failure<T1, T2, T3, T4, T5, T6, T7, T8>(await mapError(ex))
                        );
    }
    
    /// <summary>
    /// Asynchronously maps errors in the result using the specified mapping function.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <typeparam name="T5">The type of the fifth value.</typeparam>
    /// <typeparam name="T6">The type of the sixth value.</typeparam>
    /// <typeparam name="T7">The type of the seventh value.</typeparam>
    /// <typeparam name="T8">The type of the eighth value.</typeparam>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="mapError">The async function to map errors.</param>
    /// <returns>A task with a new result containing mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static async ValueTask<Result<T1, T2, T3, T4, T5, T6, T7, T8>> MapErrorAsync<T1, T2, T3, T4, T5, T6, T7, T8>(this ValueTask<Result<T1, T2, T3, T4, T5, T6, T7, T8>> awaitableResult, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull where T7 : notnull where T8 : notnull {
        var result = await awaitableResult;
        return await result.MapErrorAsync(mapError);
    }
    
    #endregion // Arity 8
}
