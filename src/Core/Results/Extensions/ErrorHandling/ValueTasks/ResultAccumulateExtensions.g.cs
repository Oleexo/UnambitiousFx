// <auto-generated>
//     This code was generated by UnambitiousFx.Core.CodeGen.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

#nullable enable

using UnambitiousFx.Core.Results.Extensions.ValueAccess.ValueTasks;
using UnambitiousFx.Core.Results.Reasons;

namespace UnambitiousFx.Core.Results.Extensions.ErrorHandling.ValueTasks;

public static partial class ResultAccumulateExtensions
{
    #region Arity 0
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <param name="original">The original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result> AccumulateAsync(this Result original, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) {
        original.TryGet(out var existingError);
        var newEx = await mapError(existingError!);
        var mapped = Result.Failure(newEx);
        foreach (var r in original.Reasons) {
            mapped.AddReason(r);
        }
        foreach (var kv in original.Metadata) {
            mapped.AddMetadata(kv.Key, kv.Value);
        }
        return mapped;
    }
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <param name="awaitableOriginal">The awaitable original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result> AccumulateAsync(this ValueTask<Result> awaitableOriginal, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) {
        var original = await awaitableOriginal;
        return await original.AccumulateAsync(mapError);
    }
    
    #endregion // Arity 0
    
    #region Arity 1
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <param name="original">The original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result<T1>> AccumulateAsync<T1>(this Result<T1> original, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull {
        original.TryGet(out _, out var existingError);
        var newEx = await mapError(existingError!);
        var mapped = Result.Failure<T1>(newEx);
        foreach (var r in original.Reasons) {
            mapped.AddReason(r);
        }
        foreach (var kv in original.Metadata) {
            mapped.AddMetadata(kv.Key, kv.Value);
        }
        return mapped;
    }
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <param name="awaitableOriginal">The awaitable original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result<T1>> AccumulateAsync<T1>(this ValueTask<Result<T1>> awaitableOriginal, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull {
        var original = await awaitableOriginal;
        return await original.AccumulateAsync(mapError);
    }
    
    #endregion // Arity 1
    
    #region Arity 2
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <param name="original">The original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result<T1, T2>> AccumulateAsync<T1, T2>(this Result<T1, T2> original, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull {
        original.TryGet(out _, out _, out var existingError);
        var newEx = await mapError(existingError!);
        var mapped = Result.Failure<T1, T2>(newEx);
        foreach (var r in original.Reasons) {
            mapped.AddReason(r);
        }
        foreach (var kv in original.Metadata) {
            mapped.AddMetadata(kv.Key, kv.Value);
        }
        return mapped;
    }
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <param name="awaitableOriginal">The awaitable original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result<T1, T2>> AccumulateAsync<T1, T2>(this ValueTask<Result<T1, T2>> awaitableOriginal, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull {
        var original = await awaitableOriginal;
        return await original.AccumulateAsync(mapError);
    }
    
    #endregion // Arity 2
    
    #region Arity 3
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <param name="original">The original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result<T1, T2, T3>> AccumulateAsync<T1, T2, T3>(this Result<T1, T2, T3> original, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull {
        original.TryGet(out _, out _, out _, out var existingError);
        var newEx = await mapError(existingError!);
        var mapped = Result.Failure<T1, T2, T3>(newEx);
        foreach (var r in original.Reasons) {
            mapped.AddReason(r);
        }
        foreach (var kv in original.Metadata) {
            mapped.AddMetadata(kv.Key, kv.Value);
        }
        return mapped;
    }
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <param name="awaitableOriginal">The awaitable original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result<T1, T2, T3>> AccumulateAsync<T1, T2, T3>(this ValueTask<Result<T1, T2, T3>> awaitableOriginal, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull {
        var original = await awaitableOriginal;
        return await original.AccumulateAsync(mapError);
    }
    
    #endregion // Arity 3
    
    #region Arity 4
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <param name="original">The original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result<T1, T2, T3, T4>> AccumulateAsync<T1, T2, T3, T4>(this Result<T1, T2, T3, T4> original, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull {
        original.TryGet(out _, out _, out _, out _, out var existingError);
        var newEx = await mapError(existingError!);
        var mapped = Result.Failure<T1, T2, T3, T4>(newEx);
        foreach (var r in original.Reasons) {
            mapped.AddReason(r);
        }
        foreach (var kv in original.Metadata) {
            mapped.AddMetadata(kv.Key, kv.Value);
        }
        return mapped;
    }
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <param name="awaitableOriginal">The awaitable original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result<T1, T2, T3, T4>> AccumulateAsync<T1, T2, T3, T4>(this ValueTask<Result<T1, T2, T3, T4>> awaitableOriginal, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull {
        var original = await awaitableOriginal;
        return await original.AccumulateAsync(mapError);
    }
    
    #endregion // Arity 4
    
    #region Arity 5
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <typeparam name="T5">The type of the fifth value.</typeparam>
    /// <param name="original">The original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result<T1, T2, T3, T4, T5>> AccumulateAsync<T1, T2, T3, T4, T5>(this Result<T1, T2, T3, T4, T5> original, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull {
        original.TryGet(out _, out _, out _, out _, out _, out var existingError);
        var newEx = await mapError(existingError!);
        var mapped = Result.Failure<T1, T2, T3, T4, T5>(newEx);
        foreach (var r in original.Reasons) {
            mapped.AddReason(r);
        }
        foreach (var kv in original.Metadata) {
            mapped.AddMetadata(kv.Key, kv.Value);
        }
        return mapped;
    }
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <typeparam name="T5">The type of the fifth value.</typeparam>
    /// <param name="awaitableOriginal">The awaitable original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result<T1, T2, T3, T4, T5>> AccumulateAsync<T1, T2, T3, T4, T5>(this ValueTask<Result<T1, T2, T3, T4, T5>> awaitableOriginal, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull {
        var original = await awaitableOriginal;
        return await original.AccumulateAsync(mapError);
    }
    
    #endregion // Arity 5
    
    #region Arity 6
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <typeparam name="T5">The type of the fifth value.</typeparam>
    /// <typeparam name="T6">The type of the sixth value.</typeparam>
    /// <param name="original">The original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result<T1, T2, T3, T4, T5, T6>> AccumulateAsync<T1, T2, T3, T4, T5, T6>(this Result<T1, T2, T3, T4, T5, T6> original, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull {
        original.TryGet(out _, out _, out _, out _, out _, out _, out var existingError);
        var newEx = await mapError(existingError!);
        var mapped = Result.Failure<T1, T2, T3, T4, T5, T6>(newEx);
        foreach (var r in original.Reasons) {
            mapped.AddReason(r);
        }
        foreach (var kv in original.Metadata) {
            mapped.AddMetadata(kv.Key, kv.Value);
        }
        return mapped;
    }
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <typeparam name="T5">The type of the fifth value.</typeparam>
    /// <typeparam name="T6">The type of the sixth value.</typeparam>
    /// <param name="awaitableOriginal">The awaitable original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result<T1, T2, T3, T4, T5, T6>> AccumulateAsync<T1, T2, T3, T4, T5, T6>(this ValueTask<Result<T1, T2, T3, T4, T5, T6>> awaitableOriginal, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull {
        var original = await awaitableOriginal;
        return await original.AccumulateAsync(mapError);
    }
    
    #endregion // Arity 6
    
    #region Arity 7
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <typeparam name="T5">The type of the fifth value.</typeparam>
    /// <typeparam name="T6">The type of the sixth value.</typeparam>
    /// <typeparam name="T7">The type of the seventh value.</typeparam>
    /// <param name="original">The original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result<T1, T2, T3, T4, T5, T6, T7>> AccumulateAsync<T1, T2, T3, T4, T5, T6, T7>(this Result<T1, T2, T3, T4, T5, T6, T7> original, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull where T7 : notnull {
        original.TryGet(out _, out _, out _, out _, out _, out _, out _, out var existingError);
        var newEx = await mapError(existingError!);
        var mapped = Result.Failure<T1, T2, T3, T4, T5, T6, T7>(newEx);
        foreach (var r in original.Reasons) {
            mapped.AddReason(r);
        }
        foreach (var kv in original.Metadata) {
            mapped.AddMetadata(kv.Key, kv.Value);
        }
        return mapped;
    }
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <typeparam name="T5">The type of the fifth value.</typeparam>
    /// <typeparam name="T6">The type of the sixth value.</typeparam>
    /// <typeparam name="T7">The type of the seventh value.</typeparam>
    /// <param name="awaitableOriginal">The awaitable original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result<T1, T2, T3, T4, T5, T6, T7>> AccumulateAsync<T1, T2, T3, T4, T5, T6, T7>(this ValueTask<Result<T1, T2, T3, T4, T5, T6, T7>> awaitableOriginal, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull where T7 : notnull {
        var original = await awaitableOriginal;
        return await original.AccumulateAsync(mapError);
    }
    
    #endregion // Arity 7
    
    #region Arity 8
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <typeparam name="T5">The type of the fifth value.</typeparam>
    /// <typeparam name="T6">The type of the sixth value.</typeparam>
    /// <typeparam name="T7">The type of the seventh value.</typeparam>
    /// <typeparam name="T8">The type of the eighth value.</typeparam>
    /// <param name="original">The original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result<T1, T2, T3, T4, T5, T6, T7, T8>> AccumulateAsync<T1, T2, T3, T4, T5, T6, T7, T8>(this Result<T1, T2, T3, T4, T5, T6, T7, T8> original, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull where T7 : notnull where T8 : notnull {
        original.TryGet(out _, out _, out _, out _, out _, out _, out _, out _, out var existingError);
        var newEx = await mapError(existingError!);
        var mapped = Result.Failure<T1, T2, T3, T4, T5, T6, T7, T8>(newEx);
        foreach (var r in original.Reasons) {
            mapped.AddReason(r);
        }
        foreach (var kv in original.Metadata) {
            mapped.AddMetadata(kv.Key, kv.Value);
        }
        return mapped;
    }
    
    /// <summary>
    /// Asynchronously accumulates errors by applying a mapping function to existing errors and preserving all reasons and metadata.
    /// </summary>
    /// <typeparam name="T1">The type of the first value.</typeparam>
    /// <typeparam name="T2">The type of the second value.</typeparam>
    /// <typeparam name="T3">The type of the third value.</typeparam>
    /// <typeparam name="T4">The type of the fourth value.</typeparam>
    /// <typeparam name="T5">The type of the fifth value.</typeparam>
    /// <typeparam name="T6">The type of the sixth value.</typeparam>
    /// <typeparam name="T7">The type of the seventh value.</typeparam>
    /// <typeparam name="T8">The type of the eighth value.</typeparam>
    /// <param name="awaitableOriginal">The awaitable original result to accumulate errors from.</param>
    /// <param name="mapError">The async function to map and accumulate errors.</param>
    /// <returns>A task with a new result containing accumulated errors, preserving all reasons and metadata from the original result.</returns>
    internal static async ValueTask<Result<T1, T2, T3, T4, T5, T6, T7, T8>> AccumulateAsync<T1, T2, T3, T4, T5, T6, T7, T8>(this ValueTask<Result<T1, T2, T3, T4, T5, T6, T7, T8>> awaitableOriginal, Func<IEnumerable<IError>, ValueTask<IEnumerable<IError>>> mapError) where T1 : notnull where T2 : notnull where T3 : notnull where T4 : notnull where T5 : notnull where T6 : notnull where T7 : notnull where T8 : notnull {
        var original = await awaitableOriginal;
        return await original.AccumulateAsync(mapError);
    }
    
    #endregion // Arity 8
}
