// <auto-generated>
//     This code was generated by UnambitiousFx.Core.CodeGen.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

#nullable enable

using UnambitiousFx.Core.Results.Reasons;

namespace UnambitiousFx.Core.Results.Extensions.ErrorHandling.Tasks;

public static partial class ResultExtensions
{
    #region Arity 0
    
    /// <summary>
    /// Asynchronously maps errors in the result to a new exception using the specified mapping function.
    /// </summary>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="map">The async function to map errors to a new exception.</param>
    /// <returns>A task with a new result containing the mapped exception if the original result failed, otherwise the original successful result.</returns>
    public static async Task<Result> MapErrorsAsync(this Task<Result> awaitableResult, Func<IEnumerable<IError>, Task<Exception>> map) {
        var result = await awaitableResult;
                        
        if (result.IsSuccess) {
            return result;
        }
        return await result.Match<Task<Result>>(() => Task.FromResult(Result.Success()), 
                                               async (errors) => {
                                                   var error = await map(errors);
                                                   return Result.Failure(error);
                                               });
    }
    
    #endregion // Arity 0
    
    #region Arity 1
    
    /// <summary>
    /// Asynchronously maps errors in the result to a new exception using the specified mapping function.
    /// </summary>
    /// <typeparam name="TValue1">The type of the first value.</typeparam>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="map">The async function to map errors to a new exception.</param>
    /// <returns>A task with a new result containing the mapped exception if the original result failed, otherwise the original successful result.</returns>
    public static async Task<Result<TValue1>> MapErrorsAsync<TValue1>(this Task<Result<TValue1>> awaitableResult, Func<IEnumerable<IError>, Task<Exception>> map) where TValue1 : notnull {
        var result = await awaitableResult;
                               
        if (result.IsSuccess) {
            return result;
        }
        return await result.Match<Task<Result<TValue1>>>((v1) => Task.FromResult(Result.Success<TValue1>(v1)), 
                                                                     async (errors) => {
                                                                         var error = await map(errors);
                                                                         return Result.Failure<TValue1>(error);
                                                                     });
    }
    
    #endregion // Arity 1
    
    #region Arity 2
    
    /// <summary>
    /// Asynchronously maps errors in the result to a new exception using the specified mapping function.
    /// </summary>
    /// <typeparam name="TValue1">The type of the first value.</typeparam>
    /// <typeparam name="TValue2">The type of the second value.</typeparam>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="map">The async function to map errors to a new exception.</param>
    /// <returns>A task with a new result containing the mapped exception if the original result failed, otherwise the original successful result.</returns>
    public static async Task<Result<TValue1, TValue2>> MapErrorsAsync<TValue1, TValue2>(this Task<Result<TValue1, TValue2>> awaitableResult, Func<IEnumerable<IError>, Task<Exception>> map) where TValue1 : notnull where TValue2 : notnull {
        var result = await awaitableResult;
                               
        if (result.IsSuccess) {
            return result;
        }
        return await result.Match<Task<Result<TValue1,TValue2>>>((v1, v2) => Task.FromResult(Result.Success<TValue1,TValue2>(v1, v2)), 
                                                                     async (errors) => {
                                                                         var error = await map(errors);
                                                                         return Result.Failure<TValue1,TValue2>(error);
                                                                     });
    }
    
    #endregion // Arity 2
    
    #region Arity 3
    
    /// <summary>
    /// Asynchronously maps errors in the result to a new exception using the specified mapping function.
    /// </summary>
    /// <typeparam name="TValue1">The type of the first value.</typeparam>
    /// <typeparam name="TValue2">The type of the second value.</typeparam>
    /// <typeparam name="TValue3">The type of the third value.</typeparam>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="map">The async function to map errors to a new exception.</param>
    /// <returns>A task with a new result containing the mapped exception if the original result failed, otherwise the original successful result.</returns>
    public static async Task<Result<TValue1, TValue2, TValue3>> MapErrorsAsync<TValue1, TValue2, TValue3>(this Task<Result<TValue1, TValue2, TValue3>> awaitableResult, Func<IEnumerable<IError>, Task<Exception>> map) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull {
        var result = await awaitableResult;
                               
        if (result.IsSuccess) {
            return result;
        }
        return await result.Match<Task<Result<TValue1,TValue2,TValue3>>>((v1, v2, v3) => Task.FromResult(Result.Success<TValue1,TValue2,TValue3>(v1, v2, v3)), 
                                                                     async (errors) => {
                                                                         var error = await map(errors);
                                                                         return Result.Failure<TValue1,TValue2,TValue3>(error);
                                                                     });
    }
    
    #endregion // Arity 3
    
    #region Arity 4
    
    /// <summary>
    /// Asynchronously maps errors in the result to a new exception using the specified mapping function.
    /// </summary>
    /// <typeparam name="TValue1">The type of the first value.</typeparam>
    /// <typeparam name="TValue2">The type of the second value.</typeparam>
    /// <typeparam name="TValue3">The type of the third value.</typeparam>
    /// <typeparam name="TValue4">The type of the fourth value.</typeparam>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="map">The async function to map errors to a new exception.</param>
    /// <returns>A task with a new result containing the mapped exception if the original result failed, otherwise the original successful result.</returns>
    public static async Task<Result<TValue1, TValue2, TValue3, TValue4>> MapErrorsAsync<TValue1, TValue2, TValue3, TValue4>(this Task<Result<TValue1, TValue2, TValue3, TValue4>> awaitableResult, Func<IEnumerable<IError>, Task<Exception>> map) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull {
        var result = await awaitableResult;
                               
        if (result.IsSuccess) {
            return result;
        }
        return await result.Match<Task<Result<TValue1,TValue2,TValue3,TValue4>>>((v1, v2, v3, v4) => Task.FromResult(Result.Success<TValue1,TValue2,TValue3,TValue4>(v1, v2, v3, v4)), 
                                                                     async (errors) => {
                                                                         var error = await map(errors);
                                                                         return Result.Failure<TValue1,TValue2,TValue3,TValue4>(error);
                                                                     });
    }
    
    #endregion // Arity 4
    
    #region Arity 5
    
    /// <summary>
    /// Asynchronously maps errors in the result to a new exception using the specified mapping function.
    /// </summary>
    /// <typeparam name="TValue1">The type of the first value.</typeparam>
    /// <typeparam name="TValue2">The type of the second value.</typeparam>
    /// <typeparam name="TValue3">The type of the third value.</typeparam>
    /// <typeparam name="TValue4">The type of the fourth value.</typeparam>
    /// <typeparam name="TValue5">The type of the fifth value.</typeparam>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="map">The async function to map errors to a new exception.</param>
    /// <returns>A task with a new result containing the mapped exception if the original result failed, otherwise the original successful result.</returns>
    public static async Task<Result<TValue1, TValue2, TValue3, TValue4, TValue5>> MapErrorsAsync<TValue1, TValue2, TValue3, TValue4, TValue5>(this Task<Result<TValue1, TValue2, TValue3, TValue4, TValue5>> awaitableResult, Func<IEnumerable<IError>, Task<Exception>> map) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull where TValue5 : notnull {
        var result = await awaitableResult;
                               
        if (result.IsSuccess) {
            return result;
        }
        return await result.Match<Task<Result<TValue1,TValue2,TValue3,TValue4,TValue5>>>((v1, v2, v3, v4, v5) => Task.FromResult(Result.Success<TValue1,TValue2,TValue3,TValue4,TValue5>(v1, v2, v3, v4, v5)), 
                                                                     async (errors) => {
                                                                         var error = await map(errors);
                                                                         return Result.Failure<TValue1,TValue2,TValue3,TValue4,TValue5>(error);
                                                                     });
    }
    
    #endregion // Arity 5
    
    #region Arity 6
    
    /// <summary>
    /// Asynchronously maps errors in the result to a new exception using the specified mapping function.
    /// </summary>
    /// <typeparam name="TValue1">The type of the first value.</typeparam>
    /// <typeparam name="TValue2">The type of the second value.</typeparam>
    /// <typeparam name="TValue3">The type of the third value.</typeparam>
    /// <typeparam name="TValue4">The type of the fourth value.</typeparam>
    /// <typeparam name="TValue5">The type of the fifth value.</typeparam>
    /// <typeparam name="TValue6">The type of the sixth value.</typeparam>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="map">The async function to map errors to a new exception.</param>
    /// <returns>A task with a new result containing the mapped exception if the original result failed, otherwise the original successful result.</returns>
    public static async Task<Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>> MapErrorsAsync<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(this Task<Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>> awaitableResult, Func<IEnumerable<IError>, Task<Exception>> map) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull where TValue5 : notnull where TValue6 : notnull {
        var result = await awaitableResult;
                               
        if (result.IsSuccess) {
            return result;
        }
        return await result.Match<Task<Result<TValue1,TValue2,TValue3,TValue4,TValue5,TValue6>>>((v1, v2, v3, v4, v5, v6) => Task.FromResult(Result.Success<TValue1,TValue2,TValue3,TValue4,TValue5,TValue6>(v1, v2, v3, v4, v5, v6)), 
                                                                     async (errors) => {
                                                                         var error = await map(errors);
                                                                         return Result.Failure<TValue1,TValue2,TValue3,TValue4,TValue5,TValue6>(error);
                                                                     });
    }
    
    #endregion // Arity 6
    
    #region Arity 7
    
    /// <summary>
    /// Asynchronously maps errors in the result to a new exception using the specified mapping function.
    /// </summary>
    /// <typeparam name="TValue1">The type of the first value.</typeparam>
    /// <typeparam name="TValue2">The type of the second value.</typeparam>
    /// <typeparam name="TValue3">The type of the third value.</typeparam>
    /// <typeparam name="TValue4">The type of the fourth value.</typeparam>
    /// <typeparam name="TValue5">The type of the fifth value.</typeparam>
    /// <typeparam name="TValue6">The type of the sixth value.</typeparam>
    /// <typeparam name="TValue7">The type of the seventh value.</typeparam>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="map">The async function to map errors to a new exception.</param>
    /// <returns>A task with a new result containing the mapped exception if the original result failed, otherwise the original successful result.</returns>
    public static async Task<Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>> MapErrorsAsync<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(this Task<Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>> awaitableResult, Func<IEnumerable<IError>, Task<Exception>> map) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull where TValue5 : notnull where TValue6 : notnull where TValue7 : notnull {
        var result = await awaitableResult;
                               
        if (result.IsSuccess) {
            return result;
        }
        return await result.Match<Task<Result<TValue1,TValue2,TValue3,TValue4,TValue5,TValue6,TValue7>>>((v1, v2, v3, v4, v5, v6, v7) => Task.FromResult(Result.Success<TValue1,TValue2,TValue3,TValue4,TValue5,TValue6,TValue7>(v1, v2, v3, v4, v5, v6, v7)), 
                                                                     async (errors) => {
                                                                         var error = await map(errors);
                                                                         return Result.Failure<TValue1,TValue2,TValue3,TValue4,TValue5,TValue6,TValue7>(error);
                                                                     });
    }
    
    #endregion // Arity 7
    
    #region Arity 8
    
    /// <summary>
    /// Asynchronously maps errors in the result to a new exception using the specified mapping function.
    /// </summary>
    /// <typeparam name="TValue1">The type of the first value.</typeparam>
    /// <typeparam name="TValue2">The type of the second value.</typeparam>
    /// <typeparam name="TValue3">The type of the third value.</typeparam>
    /// <typeparam name="TValue4">The type of the fourth value.</typeparam>
    /// <typeparam name="TValue5">The type of the fifth value.</typeparam>
    /// <typeparam name="TValue6">The type of the sixth value.</typeparam>
    /// <typeparam name="TValue7">The type of the seventh value.</typeparam>
    /// <typeparam name="TValue8">The type of the eighth value.</typeparam>
    /// <param name="awaitableResult">The awaitable result to map errors for.</param>
    /// <param name="map">The async function to map errors to a new exception.</param>
    /// <returns>A task with a new result containing the mapped exception if the original result failed, otherwise the original successful result.</returns>
    public static async Task<Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>> MapErrorsAsync<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(this Task<Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>> awaitableResult, Func<IEnumerable<IError>, Task<Exception>> map) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull where TValue5 : notnull where TValue6 : notnull where TValue7 : notnull where TValue8 : notnull {
        var result = await awaitableResult;
                               
        if (result.IsSuccess) {
            return result;
        }
        return await result.Match<Task<Result<TValue1,TValue2,TValue3,TValue4,TValue5,TValue6,TValue7,TValue8>>>((v1, v2, v3, v4, v5, v6, v7, v8) => Task.FromResult(Result.Success<TValue1,TValue2,TValue3,TValue4,TValue5,TValue6,TValue7,TValue8>(v1, v2, v3, v4, v5, v6, v7, v8)), 
                                                                     async (errors) => {
                                                                         var error = await map(errors);
                                                                         return Result.Failure<TValue1,TValue2,TValue3,TValue4,TValue5,TValue6,TValue7,TValue8>(error);
                                                                     });
    }
    
    #endregion // Arity 8
}
