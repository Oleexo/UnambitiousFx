// <auto-generated>
//     This code was generated by UnambitiousFx.Core.CodeGen.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

#nullable enable

using UnambitiousFx.Core.Results.Reasons;

namespace UnambitiousFx.Core.Results.Extensions.ErrorHandling;

public static partial class ResultMapErrorsExtensions
{
    #region Arity 0
    
    /// <summary>
    /// Maps all errors in the result using the specified mapping function to transform the error structure.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="map">The function to map the collection of exceptions to a single exception.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result MapErrors(this Result result, Func<IEnumerable<IError>, IError> map) {
        if (result.TryGet(out _)) {
          return result;
        }
        return result.Match(Result.Success,
                     (errors) => Result.Failure(map(errors)));
    }
    
    #endregion // Arity 0
    
    #region Arity 1
    
    /// <summary>
    /// Maps all errors in the result using the specified mapping function to transform the error structure.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="map">The function to map the collection of exceptions to a single exception.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<TValue1> MapErrors<TValue1>(this Result<TValue1> result, Func<IEnumerable<IError>, IError> map) where TValue1 : notnull {
        if (result.IsSuccess) {
            return result;
        }
        return result.Match(Result.Success,
                     (errors) => Result.Failure<TValue1>(map(errors)));
    }
    
    #endregion // Arity 1
    
    #region Arity 2
    
    /// <summary>
    /// Maps all errors in the result using the specified mapping function to transform the error structure.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="map">The function to map the collection of exceptions to a single exception.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<TValue1, TValue2> MapErrors<TValue1, TValue2>(this Result<TValue1, TValue2> result, Func<IEnumerable<IError>, IError> map) where TValue1 : notnull where TValue2 : notnull {
        if (result.IsSuccess) {
            return result;
        }
        return result.Match(Result.Success,
                     (errors) => Result.Failure<TValue1,TValue2>(map(errors)));
    }
    
    #endregion // Arity 2
    
    #region Arity 3
    
    /// <summary>
    /// Maps all errors in the result using the specified mapping function to transform the error structure.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="map">The function to map the collection of exceptions to a single exception.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<TValue1, TValue2, TValue3> MapErrors<TValue1, TValue2, TValue3>(this Result<TValue1, TValue2, TValue3> result, Func<IEnumerable<IError>, IError> map) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull {
        if (result.IsSuccess) {
            return result;
        }
        return result.Match(Result.Success,
                     (errors) => Result.Failure<TValue1,TValue2,TValue3>(map(errors)));
    }
    
    #endregion // Arity 3
    
    #region Arity 4
    
    /// <summary>
    /// Maps all errors in the result using the specified mapping function to transform the error structure.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="map">The function to map the collection of exceptions to a single exception.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<TValue1, TValue2, TValue3, TValue4> MapErrors<TValue1, TValue2, TValue3, TValue4>(this Result<TValue1, TValue2, TValue3, TValue4> result, Func<IEnumerable<IError>, IError> map) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull {
        if (result.IsSuccess) {
            return result;
        }
        return result.Match(Result.Success,
                     (errors) => Result.Failure<TValue1,TValue2,TValue3,TValue4>(map(errors)));
    }
    
    #endregion // Arity 4
    
    #region Arity 5
    
    /// <summary>
    /// Maps all errors in the result using the specified mapping function to transform the error structure.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="map">The function to map the collection of exceptions to a single exception.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<TValue1, TValue2, TValue3, TValue4, TValue5> MapErrors<TValue1, TValue2, TValue3, TValue4, TValue5>(this Result<TValue1, TValue2, TValue3, TValue4, TValue5> result, Func<IEnumerable<IError>, IError> map) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull where TValue5 : notnull {
        if (result.IsSuccess) {
            return result;
        }
        return result.Match(Result.Success,
                     (errors) => Result.Failure<TValue1,TValue2,TValue3,TValue4,TValue5>(map(errors)));
    }
    
    #endregion // Arity 5
    
    #region Arity 6
    
    /// <summary>
    /// Maps all errors in the result using the specified mapping function to transform the error structure.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="map">The function to map the collection of exceptions to a single exception.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6> MapErrors<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(this Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6> result, Func<IEnumerable<IError>, IError> map) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull where TValue5 : notnull where TValue6 : notnull {
        if (result.IsSuccess) {
            return result;
        }
        return result.Match(Result.Success,
                     (errors) => Result.Failure<TValue1,TValue2,TValue3,TValue4,TValue5,TValue6>(map(errors)));
    }
    
    #endregion // Arity 6
    
    #region Arity 7
    
    /// <summary>
    /// Maps all errors in the result using the specified mapping function to transform the error structure.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="map">The function to map the collection of exceptions to a single exception.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7> MapErrors<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(this Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7> result, Func<IEnumerable<IError>, IError> map) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull where TValue5 : notnull where TValue6 : notnull where TValue7 : notnull {
        if (result.IsSuccess) {
            return result;
        }
        return result.Match(Result.Success,
                     (errors) => Result.Failure<TValue1,TValue2,TValue3,TValue4,TValue5,TValue6,TValue7>(map(errors)));
    }
    
    #endregion // Arity 7
    
    #region Arity 8
    
    /// <summary>
    /// Maps all errors in the result using the specified mapping function to transform the error structure.
    /// </summary>
    /// <param name="result">The result to map errors for.</param>
    /// <param name="map">The function to map the collection of exceptions to a single exception.</param>
    /// <returns>A new result with mapped errors if the original result failed, otherwise the original successful result.</returns>
    public static Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8> MapErrors<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(this Result<TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8> result, Func<IEnumerable<IError>, IError> map) where TValue1 : notnull where TValue2 : notnull where TValue3 : notnull where TValue4 : notnull where TValue5 : notnull where TValue6 : notnull where TValue7 : notnull where TValue8 : notnull {
        if (result.IsSuccess) {
            return result;
        }
        return result.Match(Result.Success,
                     (errors) => Result.Failure<TValue1,TValue2,TValue3,TValue4,TValue5,TValue6,TValue7,TValue8>(map(errors)));
    }
    
    #endregion // Arity 8
}
