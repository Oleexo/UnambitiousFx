using System.CodeDom.Compiler;
using System.Text;
using Microsoft.CodeAnalysis.Text;

namespace UnambitiousFx.Core.Generator;

internal sealed class ResultMapErrorsExtensionsFactory(string @namespace, ushort max) {
    public SourceText Generate() {
        using var sw = new StringWriter();
        using var tw = new IndentedTextWriter(sw);
        tw.WriteLine("// <auto-generated />");
        tw.WriteLine("#nullable enable");
        tw.WriteLine("using System.Linq;");
        tw.WriteLine($"namespace {@namespace};");
        tw.WriteLine("public static partial class ResultExtensions {");
        tw.Indent++;
        // Non-generic
        tw.WriteLine("public static Result MapErrors(this Result result, System.Func<System.Collections.Generic.IReadOnlyList<System.Exception>, System.Exception> map){");
        tw.Indent++;
        tw.WriteLine("if (result.Ok(out var _)) return result;");
        tw.WriteLine("result.Ok(out var primary);");
        tw.WriteLine("var errs = CollectErrors(result, primary);");
        // create failure WITHOUT auto primary exceptional reason so we can replace instead of append
        tw.WriteLine("var newPrimary = map(errs);");
        tw.WriteLine("var failure = new FailureResult(newPrimary, attachPrimaryExceptionalReason: false);");
        tw.WriteLine("CopyReasonsAndMetadataReplacingPrimary(result, failure, primary, newPrimary); return failure;");
        tw.Indent--;
        tw.WriteLine("}");
        tw.WriteLine();
        // Helper (private) - emitted once here
        tw.WriteLine("private static System.Collections.Generic.List<System.Exception> CollectErrors(BaseResult r, System.Exception? primary){var list=new System.Collections.Generic.List<System.Exception>(); if(primary!=null) list.Add(primary); else if(!r.Ok(out var e)) list.Add(e!); foreach(var re in r.Reasons.OfType<UnambitiousFx.Core.Results.Reasons.IError>()){ if(re.Exception!=null && !list.Contains(re.Exception)) list.Add(re.Exception); else if(re.Exception==null) list.Add(new System.Exception(re.Message)); } return list; }");
        tw.WriteLine("private static void CopyReasonsAndMetadata(BaseResult from, BaseResult to){ foreach(var rs in from.Reasons) to.AddReason(rs); foreach(var kv in from.Metadata) to.AddMetadata(kv.Key, kv.Value);} ");
        // New helper to preserve reason count by replacing existing primary ExceptionalError instead of adding another one
        tw.WriteLine("private static void CopyReasonsAndMetadataReplacingPrimary(BaseResult from, BaseResult to, System.Exception? oldPrimary, System.Exception newPrimary){ bool replaced=false; foreach(var rs in from.Reasons){ if(!replaced && rs is UnambitiousFx.Core.Results.Reasons.ExceptionalError ex && oldPrimary!=null && object.ReferenceEquals(ex.Exception, oldPrimary)){ to.AddReason(new UnambitiousFx.Core.Results.Reasons.ExceptionalError(newPrimary)); replaced=true; continue; } to.AddReason(rs);} foreach(var kv in from.Metadata) to.AddMetadata(kv.Key, kv.Value); if(!replaced){ /* if there was no exceptional primary before, do not alter reason count by adding now */ } } ");
        tw.WriteLine();
        foreach(ushort i in Enumerable.Range(1,max)){
            var gen = string.Join(", ", Enumerable.Range(1,i).Select(x=>$"TValue{x}"));
            var tupleDecl = string.Join(", ", Enumerable.Range(1,i).Select(x=>$"TValue{x} value{x}"));
            tw.WriteLine($"public static Result<{gen}> MapErrors<{gen}>(this Result<{gen}> result, System.Func<System.Collections.Generic.IReadOnlyList<System.Exception>, System.Exception> map)");
            tw.Indent++; foreach(var gp in gen.Split(',').Select(s=>s.Trim())) tw.WriteLine($"where {gp} : notnull"); tw.Indent--;
            tw.WriteLine("{"); tw.Indent++;
            if(i==1){
                tw.WriteLine("if (result.Ok(out TValue1? _, out _)) return result; result.Ok(out TValue1? _, out var primary);");
            } else {
                tw.WriteLine($"if (result.Ok(out ({tupleDecl}) _, out _)) return result; result.Ok(out ({tupleDecl}) _, out var primary);");
            }
            tw.WriteLine("var errs = CollectErrors(result, primary); var newPrimary = map(errs); var failure = new FailureResult<"+gen+">(newPrimary, attachPrimaryExceptionalReason: false); CopyReasonsAndMetadataReplacingPrimary(result,failure, primary, newPrimary); return failure;");
            tw.Indent--; tw.WriteLine("}"); tw.WriteLine();
        }
        tw.Indent--;
        tw.WriteLine("}");
        return SourceText.From(sw.ToString(), Encoding.UTF8);
    }
}
